{% load static %}
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Politique de Confidentialit√© - IUT Connect+</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        /* --- VARIABLES & RESET --- */
        :root {
            --bg-color: #070a12;
            --text-main: #e0e0e0;
            --text-muted: #94a3b8;
            --gold: #D4AF37;
            --blue: #00C2FF;
            --glass-bg: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(0, 194, 255, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(212, 175, 55, 0.05) 0%, transparent 40%);
            color: var(--text-main);
            font-family: 'Montserrat', sans-serif;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            padding: 40px 20px;
        }

        /* --- CONTENEUR PRINCIPAL (ELECTRIC BORDER) --- */
        .policy-wrapper {
            max-width: 900px;
            width: 100%;
            /* L'effet √©lectrique sera g√©r√© par la classe .electric-border et le JS */
        }

        /* Contenu interne de l'effet √©lectrique */
        .policy-content {
            background: #0f1219; /* Fond sombre solide pour la lisibilit√© */
            padding: 50px;
            border-radius: 24px; /* Doit matcher le JS */
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }

        /* --- TYPOGRAPHIE --- */
        h1 {
            font-size: 2.5rem;
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--gold), var(--blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 50px;
            font-size: 0.9rem;
        }

        h2 {
            color: var(--blue);
            font-size: 1.4rem;
            margin-top: 40px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        h2::before {
            content: '';
            display: block;
            width: 5px;
            height: 25px;
            background: var(--gold);
            border-radius: 2px;
            box-shadow: 0 0 10px var(--gold);
        }

        p, li {
            color: var(--text-muted);
            font-size: 1rem;
            margin-bottom: 15px;
        }

        ul {
            list-style: none;
            padding-left: 0;
        }

        li {
            padding-left: 20px;
            position: relative;
        }

        li::before {
            content: '‚ñπ';
            color: var(--gold);
            position: absolute;
            left: 0;
        }

        /* --- CARTES GLASSMORPHISM --- */
        .glass-section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            transition: transform 0.3s, border-color 0.3s;
        }

        .glass-section:hover {
            transform: translateY(-3px);
            border-color: rgba(0, 194, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }

        /* --- LIENS & BOUTONS --- */
        a {
            color: var(--blue);
            text-decoration: none;
            transition: 0.3s;
        }
        a:hover {
            color: var(--gold);
            text-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
        }

        .btn-back {
            display: inline-flex;
            align-items: center;
            margin-top: 40px;
            padding: 12px 30px;
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: 0.3s;
        }

        .btn-back:hover {
            border-color: var(--gold);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
            transform: translateX(-5px);
        }

        /* --- MOBILE --- */
        @media (max-width: 768px) {
            .policy-content { padding: 25px; }
            h1 { font-size: 1.8rem; }
            
            /* D√©sactive l'effet √©lectrique lourd sur mobile (g√©r√© par CSS pr√©c√©dent) */
            .policy-wrapper.electric-border {
                border: 1px solid var(--glass-border);
                border-radius: 24px;
            }
        }
        



.team-card {
    /* Assure-toi que tes cartes n'ont pas de bordure native */
    border: none !important;
    background: transparent;
    /* Le fond doit √™tre g√©r√© par eb-content ou transparent */
    padding: 0;
    /* Le padding doit √™tre d√©plac√© dans eb-content si n√©cessaire */
}


/* Le contenu int√©rieur doit avoir le fond (ex: noir ou glass) pour cacher les traits √©lectriques derri√®re le texte */

.team-card .eb-content {
    background: rgba(255, 255, 255, 0.05);
    /* Ou ta couleur de carte habituelle */
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 20px;
    /* Remets ton padding ici */
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
}


/* Configuration des couleurs */

.electric-border {
    /* Tu peux changer la couleur ici */
    --electric-border-color: #00D2FF;
    --electric-light-color: #ffffff;
    /* Fallback si oklch non support√© */
    position: relative;
    border-radius: 24px;
    /* Important : doit matcher le JS */
    overflow: visible;
    isolation: isolate;
    display: inline-block;
    /* Pour coller au contenu */
}


/* Support moderne des couleurs (Optionnel mais joli) */

@supports (color: oklch(from red l c h)) {
    .electric-border {
        --electric-light-color: oklch(from var(--electric-border-color) l c h);
    }
}

.eb-canvas-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    z-index: 2;
    /* S'assure de couvrir */
}

.eb-canvas {
    display: block;
    /* Le canvas sera redimensionn√© par le JS */
}

.eb-content {
    position: relative;
    border-radius: inherit;
    z-index: 1;
    height: 100%;
    /* Important */
}

.eb-layers {
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    z-index: 0;
}

.eb-glow-1,
.eb-glow-2,
.eb-background-glow {
    position: absolute;
    inset: 0;
    border-radius: inherit;
    pointer-events: none;
    box-sizing: border-box;
}

.eb-glow-1 {
    border: 2px solid var(--electric-border-color);
    opacity: 0.6;
    filter: blur(1px);
}

.eb-glow-2 {
    border: 2px solid var(--electric-light-color);
    filter: blur(4px);
}

.eb-background-glow {
    z-index: -1;
    transform: scale(1.1);
    filter: blur(32px);
    opacity: 0.3;
    background: linear-gradient(-30deg, var(--electric-light-color), transparent, var(--electric-border-color));
}

    </style>
    
</head>
<body>

    <div class="policy-wrapper electric-border" id="rgpdDoc">
        
        <div class="eb-canvas-container"><canvas class="eb-canvas"></canvas></div>
        <div class="eb-layers">
            <div class="eb-glow-1"></div>
            <div class="eb-glow-2"></div>
            <div class="eb-background-glow"></div>
        </div>

        <div class="eb-content policy-content">
            
            <h1>Protection des Donn√©es</h1>
            <p class="subtitle">Derni√®re mise √† jour : Janvier 2026</p>

            <div class="glass-section">
                <h2>1. Pr√©ambule</h2>
                <p>
                    Bienvenue sur <strong>IUT Connect+</strong>. Cette application a √©t√© d√©velopp√©e dans le cadre de la gestion des parrainages et des activit√©s du Club Informatique de l'IUT de Ngaound√©r√©.
                    Nous attachons une importance capitale √† la confidentialit√© de vos donn√©es acad√©miques et personnelles.
                </p>
            </div>

            <div class="glass-section">
                <h2>2. Donn√©es Collect√©es</h2>
                <p>Nous collectons uniquement les donn√©es strictement n√©cessaires au bon fonctionnement du service :</p>
                <ul>
                    <li><strong>Identit√© :</strong> Nom, Pr√©nom, Matricule √©tudiant.</li>
                    <li><strong>Contact :</strong> Adresse email institutionnelle ou personnelle.</li>
                    <li><strong>Acad√©mique :</strong> Niveau d'√©tude (L1, L2, etc.), Fili√®re (R√©seau & T√©l√©com, etc.).</li>
                    <li><strong>S√©curit√© :</strong> Mots de passe (stock√©s de mani√®re chiffr√©e/hash√©e) et logs de connexion.</li>
                    <li><strong>M√©dias :</strong> Photos de profil (si t√©l√©charg√©es par l'utilisateur).</li>
                </ul>
            </div>

            <div class="glass-section">
                <h2>3. Utilisation des Donn√©es</h2>
                <p>Vos informations sont trait√©es pour les finalit√©s suivantes :</p>
                <ul>
                    <li>Organisation de la "Soir√©e de Parrainage" (assignation automatique parrain/filleul).</li>
                    <li>Gestion des acc√®s √† la plateforme (authentification s√©curis√©e).</li>
                    <li>Envoi de notifications importantes (r√©initialisation de mot de passe, alertes admin).</li>
                    <li>Statistiques anonymes pour le Club Informatique.</li>
                </ul>
                <p><em>Aucune donn√©e n'est revendue √† des tiers.</em></p>
            </div>

            <div class="glass-section">
                <h2>4. S√©curit√©</h2>
                <p>
                    Nous mettons en ≈ìuvre des mesures techniques robustes :
                    chiffrement SSL (HTTPS), hachage des mots de passe (PBKDF2/Argon2), protection contre les attaques CSRF et XSS, et surveillance des erreurs via Sentry/Logs.
                </p>
            </div>

            <div class="glass-section">
                <h2>5. Vos Droits (Loi Informatique et Libert√©s)</h2>
                <p>Conform√©ment √† la r√©glementation, vous disposez des droits suivants :</p>
                <ul>
                    <li>Droit d'acc√®s et de rectification de vos donn√©es.</li>
                    <li>Droit √† l'effacement ("Droit √† l'oubli") apr√®s la fin de votre scolarit√© ou de l'√©v√©nement.</li>
                    <li>Droit de retirer votre consentement √† tout moment.</li>
                </ul>
                <p style="margin-top: 15px;">
                    Pour exercer ces droits, contactez l'administrateur :<br>
                    <a href="mailto:siddick369@gmail.com">üì© siddick369@gmail.com</a>
                </p>
            </div>

            <div style="text-align: center;">
                <a href="{% url 'accueil' %}" class="btn-back">
                    ‚Üê Retour √† l'accueil
                </a>
            </div>

        </div>
    </div>

    <script>
    class ElectricBorderAnimation {
        constructor(target, options = {}) {
            // Optimisation Mobile
            if (window.innerWidth < 768) return; 

            this.container = typeof target === 'string' ? document.getElementById(target) : target;
            if (!this.container) return;
            
            this.canvas = this.container.querySelector('.eb-canvas');
            this.ctx = this.canvas.getContext('2d');
            
            this.color = options.color || '#00D2FF';
            this.speed = options.speed || 1;
            this.chaos = options.chaos || 0.12;
            this.borderRadius = options.borderRadius || 24;
            
            this.container.style.setProperty('--electric-border-color', this.color);

            this.time = 0;
            this.lastTime = 0;
            
            this.octaves = 10;
            this.lacunarity = 1.6;
            this.gain = 0.7;
            this.frequency = 10;
            this.displacement = 60;
            this.borderOffset = 60;

            this.resizeObserver = new ResizeObserver(() => this.updateSize());
            this.resizeObserver.observe(this.container);
            this.updateSize();
            this.animate(0);
        }

        random(x) { return (Math.sin(x * 12.9898) * 43758.5453) % 1; }
        noise2D(x, y) {
            const i = Math.floor(x); const j = Math.floor(y);
            const fx = x - i; const fy = y - j;
            const a = this.random(i + j * 57); const b = this.random(i + 1 + j * 57);
            const c = this.random(i + (j + 1) * 57); const d = this.random(i + 1 + (j + 1) * 57);
            const ux = fx * fx * (3.0 - 2.0 * fx); const uy = fy * fy * (3.0 - 2.0 * fy);
            return a * (1 - ux) * (1 - uy) + b * ux * (1 - uy) + c * (1 - ux) * uy + d * ux * uy;
        }
        octavedNoise(x, time, seed) {
            let y = 0; let amplitude = this.chaos; let frequency = this.frequency;
            for (let i = 0; i < this.octaves; i++) {
                y += amplitude * this.noise2D(frequency * x + seed * 100, time * frequency * 0.3);
                frequency *= this.lacunarity; amplitude *= this.gain;
            }
            return y;
        }
        getRoundedRectPoint(t, width, height, radius) {
            const left = this.borderOffset; const top = this.borderOffset;
            const straightW = width - 2 * radius; const straightH = height - 2 * radius;
            const cornerArc = (Math.PI * radius) / 2;
            const totalPerimeter = 2 * straightW + 2 * straightH + 4 * cornerArc;
            const distance = t * totalPerimeter;
            let acc = 0;
            const getCorner = (cx, cy, r, sa, ea, p) => ({ x: cx + r * Math.cos(sa + p * ea), y: cy + r * Math.sin(sa + p * ea) });
            if (distance <= acc + straightW) return { x: left + radius + (distance - acc), y: top }; acc += straightW;
            if (distance <= acc + cornerArc) return getCorner(left + width - radius, top + radius, radius, -Math.PI/2, Math.PI/2, (distance - acc)/cornerArc); acc += cornerArc;
            if (distance <= acc + straightH) return { x: left + width, y: top + radius + (distance - acc) }; acc += straightH;
            if (distance <= acc + cornerArc) return getCorner(left + width - radius, top + height - radius, radius, 0, Math.PI/2, (distance - acc)/cornerArc); acc += cornerArc;
            if (distance <= acc + straightW) return { x: left + width - radius - (distance - acc), y: top + height }; acc += straightW;
            if (distance <= acc + cornerArc) return getCorner(left + radius, top + height - radius, Math.PI/2, Math.PI/2, (distance - acc)/cornerArc); acc += cornerArc;
            if (distance <= acc + straightH) return { x: left, y: top + height - radius - (distance - acc) }; acc += straightH;
            return getCorner(left + radius, top + radius, radius, Math.PI, Math.PI/2, (distance - acc)/cornerArc);
        }
        updateSize() {
            const width = this.container.offsetWidth;
            const height = this.container.offsetHeight;
            this.width = width + this.borderOffset * 2;
            this.height = height + this.borderOffset * 2;
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.canvas.width = this.width * dpr;
            this.canvas.height = this.height * dpr;
            this.canvas.style.width = `${this.width}px`;
            this.canvas.style.height = `${this.height}px`;
            this.ctx.scale(dpr, dpr);
        }
        animate(currentTime) {
            if (!this.lastTime) this.lastTime = currentTime;
            const deltaTime = (currentTime - this.lastTime) / 1000;
            this.time += deltaTime * this.speed;
            this.lastTime = currentTime;
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.scale(dpr, dpr);
            this.ctx.strokeStyle = this.color;
            this.ctx.lineWidth = 1.5;
            this.ctx.lineCap = 'round'; this.ctx.lineJoin = 'round';
            const cW = this.width - 2 * this.borderOffset;
            const cH = this.height - 2 * this.borderOffset;
            const r = Math.min(this.borderRadius, Math.min(cW, cH) / 2);
            const perimeter = 2 * (cW + cH) + 2 * Math.PI * r;
            const count = Math.floor(perimeter / 2);
            this.ctx.beginPath();
            for (let i = 0; i <= count; i++) {
                const p = i / count;
                const pt = this.getRoundedRectPoint(p, cW, cH, r);
                const xN = this.octavedNoise(p * 8, this.time, 0);
                const yN = this.octavedNoise(p * 8, this.time, 1);
                const x = pt.x + xN * this.displacement;
                const y = pt.y + yN * this.displacement;
                if (i === 0) this.ctx.moveTo(x, y); else this.ctx.lineTo(x, y);
            }
            this.ctx.closePath();
            this.ctx.stroke();
            requestAnimationFrame((t) => this.animate(t));
        }
    }

    // Lancement de l'effet sur le conteneur principal
    document.addEventListener('DOMContentLoaded', () => {
        new ElectricBorderAnimation('rgpdDoc', {
            color: '#00C2FF', // Bleu Cyan "Securit√©"
            speed: 0.8,       // Un peu plus lent pour un doc officiel
            chaos: 0.08,      // Calme et stable
            borderRadius: 24
        });
    });
    </script>
</body>
</html>